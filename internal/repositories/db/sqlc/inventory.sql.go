// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: inventory.sql

package db

import (
	"context"
	"database/sql"
)

const addInventoryItem = `-- name: AddInventoryItem :execresult
INSERT INTO inventory_items (
    inventory_id,
    item_type,
    item_id,
    quantity,
    is_equipped,
    notes
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type AddInventoryItemParams struct {
	InventoryID int64
	ItemType    string
	ItemID      int64
	Quantity    int64
	IsEquipped  bool
	Notes       sql.NullString
}

func (q *Queries) AddInventoryItem(ctx context.Context, arg AddInventoryItemParams) (sql.Result, error) {
	return q.exec(ctx, q.addInventoryItemStmt, addInventoryItem,
		arg.InventoryID,
		arg.ItemType,
		arg.ItemID,
		arg.Quantity,
		arg.IsEquipped,
		arg.Notes,
	)
}

const createInventory = `-- name: CreateInventory :execresult
INSERT INTO inventories (
    character_id,
    max_weight,
    current_weight
) VALUES (
    ?,
    ?,
    0
)
`

type CreateInventoryParams struct {
	CharacterID int64
	MaxWeight   float64
}

func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) (sql.Result, error) {
	return q.exec(ctx, q.createInventoryStmt, createInventory, arg.CharacterID, arg.MaxWeight)
}

const deleteInventory = `-- name: DeleteInventory :exec
DELETE FROM inventories
WHERE id = ?
`

func (q *Queries) DeleteInventory(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteInventoryStmt, deleteInventory, id)
	return err
}

const getInventory = `-- name: GetInventory :one
SELECT id, character_id, max_weight, current_weight, created_at, updated_at FROM inventories
WHERE id = ? LIMIT 1
`

func (q *Queries) GetInventory(ctx context.Context, id int64) (Inventory, error) {
	row := q.queryRow(ctx, q.getInventoryStmt, getInventory, id)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.MaxWeight,
		&i.CurrentWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryByCharacter = `-- name: GetInventoryByCharacter :one
SELECT id, character_id, max_weight, current_weight, created_at, updated_at FROM inventories
WHERE character_id = ? LIMIT 1
`

func (q *Queries) GetInventoryByCharacter(ctx context.Context, characterID int64) (Inventory, error) {
	row := q.queryRow(ctx, q.getInventoryByCharacterStmt, getInventoryByCharacter, characterID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.MaxWeight,
		&i.CurrentWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItem = `-- name: GetInventoryItem :one
SELECT id, inventory_id, item_type, item_id, quantity, is_equipped, notes, created_at, updated_at FROM inventory_items
WHERE id = ? LIMIT 1
`

func (q *Queries) GetInventoryItem(ctx context.Context, id int64) (InventoryItem, error) {
	row := q.queryRow(ctx, q.getInventoryItemStmt, getInventoryItem, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.InventoryID,
		&i.ItemType,
		&i.ItemID,
		&i.Quantity,
		&i.IsEquipped,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItemByTypeAndItemID = `-- name: GetInventoryItemByTypeAndItemID :one
SELECT id, inventory_id, item_type, item_id, quantity, is_equipped, notes, created_at, updated_at FROM inventory_items
WHERE inventory_id = ? AND item_type = ? AND item_id = ?
LIMIT 1
`

type GetInventoryItemByTypeAndItemIDParams struct {
	InventoryID int64
	ItemType    string
	ItemID      int64
}

func (q *Queries) GetInventoryItemByTypeAndItemID(ctx context.Context, arg GetInventoryItemByTypeAndItemIDParams) (InventoryItem, error) {
	row := q.queryRow(ctx, q.getInventoryItemByTypeAndItemIDStmt, getInventoryItemByTypeAndItemID, arg.InventoryID, arg.ItemType, arg.ItemID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.InventoryID,
		&i.ItemType,
		&i.ItemID,
		&i.Quantity,
		&i.IsEquipped,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItems = `-- name: GetInventoryItems :many
SELECT id, inventory_id, item_type, item_id, quantity, is_equipped, notes, created_at, updated_at FROM inventory_items
WHERE inventory_id = ?
ORDER BY id
`

func (q *Queries) GetInventoryItems(ctx context.Context, inventoryID int64) ([]InventoryItem, error) {
	rows, err := q.query(ctx, q.getInventoryItemsStmt, getInventoryItems, inventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryItem{}
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.InventoryID,
			&i.ItemType,
			&i.ItemID,
			&i.Quantity,
			&i.IsEquipped,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemsByType = `-- name: GetInventoryItemsByType :many
SELECT id, inventory_id, item_type, item_id, quantity, is_equipped, notes, created_at, updated_at FROM inventory_items
WHERE inventory_id = ? AND item_type = ?
ORDER BY id
`

type GetInventoryItemsByTypeParams struct {
	InventoryID int64
	ItemType    string
}

func (q *Queries) GetInventoryItemsByType(ctx context.Context, arg GetInventoryItemsByTypeParams) ([]InventoryItem, error) {
	rows, err := q.query(ctx, q.getInventoryItemsByTypeStmt, getInventoryItemsByType, arg.InventoryID, arg.ItemType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryItem{}
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.InventoryID,
			&i.ItemType,
			&i.ItemID,
			&i.Quantity,
			&i.IsEquipped,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventories = `-- name: ListInventories :many
SELECT id, character_id, max_weight, current_weight, created_at, updated_at FROM inventories
ORDER BY id
`

func (q *Queries) ListInventories(ctx context.Context) ([]Inventory, error) {
	rows, err := q.query(ctx, q.listInventoriesStmt, listInventories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.MaxWeight,
			&i.CurrentWeight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllInventoryItems = `-- name: RemoveAllInventoryItems :exec
DELETE FROM inventory_items
WHERE inventory_id = ?
`

func (q *Queries) RemoveAllInventoryItems(ctx context.Context, inventoryID int64) error {
	_, err := q.exec(ctx, q.removeAllInventoryItemsStmt, removeAllInventoryItems, inventoryID)
	return err
}

const removeInventoryItem = `-- name: RemoveInventoryItem :exec
DELETE FROM inventory_items
WHERE id = ?
`

func (q *Queries) RemoveInventoryItem(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.removeInventoryItemStmt, removeInventoryItem, id)
	return err
}

const updateInventory = `-- name: UpdateInventory :execresult
UPDATE inventories
SET 
    max_weight = COALESCE(?2, max_weight),
    current_weight = COALESCE(?3, current_weight)
WHERE id = ?
`

type UpdateInventoryParams struct {
	MaxWeight     sql.NullFloat64
	CurrentWeight sql.NullFloat64
	ID            int64
}

func (q *Queries) UpdateInventory(ctx context.Context, arg UpdateInventoryParams) (sql.Result, error) {
	return q.exec(ctx, q.updateInventoryStmt, updateInventory, arg.MaxWeight, arg.CurrentWeight, arg.ID)
}

const updateInventoryItem = `-- name: UpdateInventoryItem :execresult
UPDATE inventory_items
SET 
    quantity = COALESCE(?2, quantity),
    is_equipped = COALESCE(?3, is_equipped),
    notes = COALESCE(?4, notes)
WHERE id = ?
`

type UpdateInventoryItemParams struct {
	Quantity   sql.NullInt64
	IsEquipped sql.NullBool
	Notes      sql.NullString
	ID         int64
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) (sql.Result, error) {
	return q.exec(ctx, q.updateInventoryItemStmt, updateInventoryItem,
		arg.Quantity,
		arg.IsEquipped,
		arg.Notes,
		arg.ID,
	)
}
