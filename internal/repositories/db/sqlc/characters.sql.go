// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: characters.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createCharacter = `-- name: CreateCharacter :execresult
INSERT INTO characters (
  user_id, name, class, level, strength, dexterity, constitution,
  wisdom, intelligence, charisma, hit_points, experience_points
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterParams struct {
	UserID           int64
	Name             string
	Class            string
	Level            int64
	Strength         int64
	Dexterity        int64
	Constitution     int64
	Wisdom           int64
	Intelligence     int64
	Charisma         int64
	HitPoints        int64
	ExperiencePoints int64
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (sql.Result, error) {
	return q.exec(ctx, q.createCharacterStmt, createCharacter,
		arg.UserID,
		arg.Name,
		arg.Class,
		arg.Level,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Wisdom,
		arg.Intelligence,
		arg.Charisma,
		arg.HitPoints,
		arg.ExperiencePoints,
	)
}

const deleteCharacter = `-- name: DeleteCharacter :execresult
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) (sql.Result, error) {
	return q.exec(ctx, q.deleteCharacterStmt, deleteCharacter, id)
}

const getCharacter = `-- name: GetCharacter :one
SELECT id, user_id, name, class, level, strength, dexterity, constitution,
       wisdom, intelligence, charisma, hit_points, experience_points,
       created_at, updated_at
FROM characters
WHERE id = ? LIMIT 1
`

type GetCharacterRow struct {
	ID               int64
	UserID           int64
	Name             string
	Class            string
	Level            int64
	Strength         int64
	Dexterity        int64
	Constitution     int64
	Wisdom           int64
	Intelligence     int64
	Charisma         int64
	HitPoints        int64
	ExperiencePoints int64
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetCharacter(ctx context.Context, id int64) (GetCharacterRow, error) {
	row := q.queryRow(ctx, q.getCharacterStmt, getCharacter, id)
	var i GetCharacterRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Wisdom,
		&i.Intelligence,
		&i.Charisma,
		&i.HitPoints,
		&i.ExperiencePoints,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharactersByUser = `-- name: GetCharactersByUser :many
SELECT id, user_id, name, class, level, strength, dexterity, constitution,
       wisdom, intelligence, charisma, hit_points, experience_points,
       created_at, updated_at
FROM characters
WHERE user_id = ?
ORDER BY name
`

type GetCharactersByUserRow struct {
	ID               int64
	UserID           int64
	Name             string
	Class            string
	Level            int64
	Strength         int64
	Dexterity        int64
	Constitution     int64
	Wisdom           int64
	Intelligence     int64
	Charisma         int64
	HitPoints        int64
	ExperiencePoints int64
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetCharactersByUser(ctx context.Context, userID int64) ([]GetCharactersByUserRow, error) {
	rows, err := q.query(ctx, q.getCharactersByUserStmt, getCharactersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCharactersByUserRow{}
	for rows.Next() {
		var i GetCharactersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Class,
			&i.Level,
			&i.Strength,
			&i.Dexterity,
			&i.Constitution,
			&i.Wisdom,
			&i.Intelligence,
			&i.Charisma,
			&i.HitPoints,
			&i.ExperiencePoints,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT id, user_id, name, class, level, strength, dexterity, constitution,
       wisdom, intelligence, charisma, hit_points, experience_points,
       created_at, updated_at
FROM characters
ORDER BY name
`

type ListCharactersRow struct {
	ID               int64
	UserID           int64
	Name             string
	Class            string
	Level            int64
	Strength         int64
	Dexterity        int64
	Constitution     int64
	Wisdom           int64
	Intelligence     int64
	Charisma         int64
	HitPoints        int64
	ExperiencePoints int64
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.query(ctx, q.listCharactersStmt, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCharactersRow{}
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Class,
			&i.Level,
			&i.Strength,
			&i.Dexterity,
			&i.Constitution,
			&i.Wisdom,
			&i.Intelligence,
			&i.Charisma,
			&i.HitPoints,
			&i.ExperiencePoints,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacter = `-- name: UpdateCharacter :execresult
UPDATE characters
SET name = ?,
    class = ?,
    level = ?,
    strength = ?,
    dexterity = ?,
    constitution = ?,
    wisdom = ?,
    intelligence = ?,
    charisma = ?,
    hit_points = ?,
    experience_points = ?,
    updated_at = datetime('now')
WHERE id = ?
`

type UpdateCharacterParams struct {
	Name             string
	Class            string
	Level            int64
	Strength         int64
	Dexterity        int64
	Constitution     int64
	Wisdom           int64
	Intelligence     int64
	Charisma         int64
	HitPoints        int64
	ExperiencePoints int64
	ID               int64
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) (sql.Result, error) {
	return q.exec(ctx, q.updateCharacterStmt, updateCharacter,
		arg.Name,
		arg.Class,
		arg.Level,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Wisdom,
		arg.Intelligence,
		arg.Charisma,
		arg.HitPoints,
		arg.ExperiencePoints,
		arg.ID,
	)
}
